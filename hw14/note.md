## 这就是美国

### 问题描述
- n个点的树，m条边，每条边有两个权值 a[i] 和 b[i]
- 需要选择边使得图连通
- 代价函数：max(a) * S + max(b) * T
- 求最小代价

### 算法思路
枚举所有可能的 (a_max, b_max) 组合：
- 最优解必然在某条边的 a 或 b 值处取得
- 对于固定的 a_max，在 a ≤ a_max 的边中按 b 排序做 Kruskal，找最小 b_max

### 数据结构优化
**方案对比**：
1.  用 set 存储考虑的边：插入 O(log m)，但遍历慢，需要手搓红黑树中序遍历
    分支复杂，内存不连续，对实际数据结构很不友好，遍历就很慢
    遍历是高需求成本
2.  **用 vector 维护按 b 有序的边集合**：
   - 二分插入：O(log m) 查找 + O(m) 移动
   - 虽然单次插入 O(m)，但已经有序，Kruskal 可以直接遍历
   - 我们的算法是每次加多一个边（已经按照a升序，a_max 逐渐提高，而每次加边都需要kruskal全部遍历一遍 ， 所以遍历是多的，插入是少的）
   - 避免每次重新排序 O(m log m)

### 核心优化：增量构建有序边集
```cpp
// 按 a 排序
sort(edges by a);

vector<edge> active_edges; // 维护按 b 有序的边集合

for (int i = 0; i < m; i++) {
    int a_max = edges[i].a;
    
    // 二分插入，保持 active_edges 按 b 有序
    int pos = lower_bound(active_edges, edges[i], compare_by_b);
    active_edges.insert(pos, edges[i]);
    
    // 用已排序的 active_edges 直接做 Kruskal
    // 不需要重新排序！
}
```

### 时间复杂度分析
| 方法 | 排序次数 | 单次复杂度 | 总复杂度 |
|------|---------|-----------|----------|
| 暴力枚举 a_max | m 次 | O(m log m) | O(m² log m) ❌ |
| **增量维护有序集合** | 1 次 | O(m) 插入 + O(m) Kruskal | **O(m²)** ✅ |


#### **总结：何时选择哪种数据结构**

##### **选择 vector 的条件**（本题满足）：
1. ✅ **频繁遍历**（遍历次数 >> 插入次数）
2. ✅ **随机访问**（从头到尾）
3. ✅ **元素较小**（cache line 利用率高）
4. ✅ **插入位置可预测**（二分查找）

##### **选择 set 的条件**：
1. ✅ 频繁插入/删除（修改次数 >> 遍历次数）
2. ✅ 需要自动去重
3. ✅ 需要快速查找特定元素
4. ✅ 顺序访问模式

##### **选择 vector 的场景**（本题满足）：
1. ✅ **频繁顺序遍历**（遍历次数 >> 插入次数）
2. ✅ **需要连续内存**（cache 友好）
3. ✅ **随机访问**（O(1) 通过下标访问）
4. ✅ **插入位置可预测**（如二分查找后插入）
5. ✅ **元素大小适中**（cache line 利用率高）

**典型应用**：
- 需要频繁遍历的有序序列
- 需要按下标访问的场景
- 动态规划的状态数组
- 需要 reserve 预分配内存

##### **选择 set 的场景**：
1. ✅ **频繁插入/删除**（修改次数 >> 遍历次数）
2. ✅ **需要自动去重**
3. ✅ **需要动态维护有序性**（插入后自动排序）
4. ✅ **查找特定元素**（O(log n) 的 find 操作）
5. ✅ **需要范围查询**（lower_bound, upper_bound）

**典型应用**：
- 需要去重的有序集合
- 需要频繁查询某元素是否存在
- 需要动态插入并保持有序（如事件队列）
- **不需要频繁遍历全部元素**

### 关键点
- ✅ 预排序 + 增量构建，避免重复排序
- ✅ 维护有序结构，利用二分插入
- ✅ 单次遍历，不重复筛选边
- ⚠️ 即使单次插入 O(m)，因为避免了 O(m log m) 排序，整体仍更快

---

## 这就是法国

特殊情况下的最小生成树
允许 c[i] + c[j] 建立 i，j 之间
-> 加入超级源点表示这种加边方式，(p0, i) 边权是 c[i]，经过 p[0] 就是特殊方式的边

如果 m 是 O(n²)；那 Prim 的 n² 反而是更快的
优于 O(m log m)

---

## 这就是俄国 I (混合边权的最小生成树)

### 问题描述
- n 座城市，每座城市有警戒值 a[i]
- 建立新通信线：连接城市 u 和 v 的代价 = a[u] + a[v]
- 重启旧通信线：m 条旧线路，代价 = w[i]
- 求使所有城市连通的最小代价

### 问题本质
两种边权的 MST 问题：
| 边类型 | 数量 | 边权 | 来源 |
|--------|------|------|------|
| 旧通信线 | m 条 | w[i] | 题目输入 |
| 新通信线 | C(n,2) 条 | a[u] + a[v] | 自己建立 |

**朴素做法**：m + n(n-1)/2 条边跑 Kruskal → **O(n² log n)** ❌

### 核心优化：星形拓扑

**关键洞察**：
- 找全局最小警戒值 a[min]，对应城市为 globalMinIdx
- 任意两城市 i, j 建新线有两种方案：
  1. 直接连接：a[i] + a[j]
  2. 通过 min 中转：(a[i] + a[min]) + (a[j] + a[min])

**优化策略**：
```cpp
// 只建立 n-1 条新边：每个城市连向最小警戒城市
for (int i = 1; i <= n; i++) {
    if (i != globalMinIdx) {
        edges.push_back({i, globalMinIdx, a[i] + a[min]});
    }
}
```

**为什么可行？**
```
a[i] + a[min] ≤ a[i] + a[j]  (因为 a[min] ≤ a[j])
```
通过最小城市中转，每条边的代价都**不大于**直接连接！

### 算法流程
1. 找全局最小警戒值 O(n)
2. 读入 m 条旧边
3. 添加 n-1 条星形新边（连向 globalMinIdx）
4. 对 m + n - 1 条边跑 Kruskal

### 时间复杂度
- 找最小值：O(n)
- 建边：O(m + n)
- 排序：O((m+n) log(m+n))
- Kruskal：O((m+n) α(n))
- **总计**：**O((m+n) log(m+n))** ✅

### 样例验证
**样例 2**：
```
输入：4 0
      1 3 3 7

最小警戒值：a[1] = 1
新边：
  2-1: 3+1=4
  3-1: 3+1=4
  4-1: 7+1=8

MST：4 + 4 + 8 = 16 ✅
```

### 核心技巧总结
- ✅ **“势能类型边权”星形拓扑优化**：利用全局最小点作为"中转站"
- ✅ **避免 O(n²) 建边**：从 n(n-1)/2 条 → n-1 条
- ✅ **最优性保证**：通过最小点中转总是最优选择
- ✅ **适用场景**：点权可以购买边 + 最小生成树

### 算法模板
```cpp
// 1. 找最小点权
int minIdx = 1;
ll minVal = a[1];
for (int i = 2; i <= n; i++) {
    if (a[i] < minVal) {
        minVal = a[i];
        minIdx = i;
    }
}

// 2. 建星形边
for (int i = 1; i <= n; i++) {
    if (i != minIdx) {
        edges.push_back({i, minIdx, a[i] + minVal});
    }
}

// 3. 合并旧边 + 新边，跑 Kruskal
sort(edges);
// ... Kruskal 算法
```

### 扩展
如果 m = O(n²)（稠密图），可以考虑：
- **Prim 算法**：朴素O(n²) 可能更优
- 避免排序开销

### prim
1. 选择起点加入树
2. 找所有一端在树内、一端在树外的边中的最小边
3. 将该边和新点加入树
4. 重复直到所有点都在树内

**只有一个（一对）点集，所以维护点集并不需要并查集，而是直接bool数组表示是否入栈即可**


```
// 适合稠密图
vector<vector<pair<int, ll>>> adj(n + 1);  // 邻接表
vector<bool> inTree(n + 1, false);         // 是否在树中
vector<ll> minCost(n + 1, LLONG_MAX);      // 到树的最小代价

// 从点 1 开始
minCost[1] = 0;
ll totalCost = 0;

for (int i = 1; i <= n; i++) {  // 加入 n 个点
    // 1. 找不在树中且距离最小的点
    int u = -1;
    ll minDist = LLONG_MAX;
    
    for (int v = 1; v <= n; v++) {
        if (!inTree[v] && minCost[v] < minDist) {
            minDist = minCost[v];
            u = v;
        }
    }
    
    if (u == -1) break;  // 图不连通
    
    // 2. 将 u 加入树
    inTree[u] = true;
    totalCost += minCost[u];
    
    // 3. 更新 u 的邻居到树的最小距离
    for (auto [v, w] : adj[u]) {
        if (!inTree[v] && w < minCost[v]) {
            minCost[v] = w;
        }
    }
}

cout << totalCost << '\n';
```